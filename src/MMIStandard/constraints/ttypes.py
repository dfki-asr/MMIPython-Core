#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import MMIStandard.math.ttypes
import MMIStandard.avatar.ttypes

from thrift.transport import TTransport
all_structs = []


class MTranslationConstraintType(object):
    BOX = 0
    ELLIPSOID = 1

    _VALUES_TO_NAMES = {
        0: "BOX",
        1: "ELLIPSOID",
    }

    _NAMES_TO_VALUES = {
        "BOX": 0,
        "ELLIPSOID": 1,
    }


class MInterval(object):
    """
    Attributes:
     - Min
     - Max

    """


    def __init__(self, Min=None, Max=None,):
        self.Min = Min
        self.Max = Max

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.Min = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.Max = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MInterval')
        if self.Min is not None:
            oprot.writeFieldBegin('Min', TType.DOUBLE, 1)
            oprot.writeDouble(self.Min)
            oprot.writeFieldEnd()
        if self.Max is not None:
            oprot.writeFieldBegin('Max', TType.DOUBLE, 2)
            oprot.writeDouble(self.Max)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Min is None:
            raise TProtocolException(message='Required field Min is unset!')
        if self.Max is None:
            raise TProtocolException(message='Required field Max is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MInterval3(object):
    """
    Attributes:
     - X
     - Y
     - Z

    """


    def __init__(self, X=None, Y=None, Z=None,):
        self.X = X
        self.Y = Y
        self.Z = Z

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.X = MInterval()
                    self.X.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.Y = MInterval()
                    self.Y.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.Z = MInterval()
                    self.Z.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MInterval3')
        if self.X is not None:
            oprot.writeFieldBegin('X', TType.STRUCT, 1)
            self.X.write(oprot)
            oprot.writeFieldEnd()
        if self.Y is not None:
            oprot.writeFieldBegin('Y', TType.STRUCT, 2)
            self.Y.write(oprot)
            oprot.writeFieldEnd()
        if self.Z is not None:
            oprot.writeFieldBegin('Z', TType.STRUCT, 3)
            self.Z.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.X is None:
            raise TProtocolException(message='Required field X is unset!')
        if self.Y is None:
            raise TProtocolException(message='Required field Y is unset!')
        if self.Z is None:
            raise TProtocolException(message='Required field Z is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MTranslationConstraint(object):
    """
    Attributes:
     - Type
     - Limits

    """


    def __init__(self, Type=None, Limits=None,):
        self.Type = Type
        self.Limits = Limits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.Type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.Limits = MInterval3()
                    self.Limits.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MTranslationConstraint')
        if self.Type is not None:
            oprot.writeFieldBegin('Type', TType.I32, 1)
            oprot.writeI32(self.Type)
            oprot.writeFieldEnd()
        if self.Limits is not None:
            oprot.writeFieldBegin('Limits', TType.STRUCT, 2)
            self.Limits.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Type is None:
            raise TProtocolException(message='Required field Type is unset!')
        if self.Limits is None:
            raise TProtocolException(message='Required field Limits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MRotationConstraint(object):
    """
    Attributes:
     - Limits

    """


    def __init__(self, Limits=None,):
        self.Limits = Limits

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.Limits = MInterval3()
                    self.Limits.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MRotationConstraint')
        if self.Limits is not None:
            oprot.writeFieldBegin('Limits', TType.STRUCT, 2)
            self.Limits.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.Limits is None:
            raise TProtocolException(message='Required field Limits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MGeometryConstraint(object):
    """
    Attributes:
     - ParentObjectID
     - ParentToConstraint
     - TranslationConstraint
     - RotationConstraint
     - WeightingFactor

    """


    def __init__(self, ParentObjectID=None, ParentToConstraint=None, TranslationConstraint=None, RotationConstraint=None, WeightingFactor=None,):
        self.ParentObjectID = ParentObjectID
        self.ParentToConstraint = ParentToConstraint
        self.TranslationConstraint = TranslationConstraint
        self.RotationConstraint = RotationConstraint
        self.WeightingFactor = WeightingFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ParentObjectID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ParentToConstraint = MMIStandard.math.ttypes.MTransform()
                    self.ParentToConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.TranslationConstraint = MTranslationConstraint()
                    self.TranslationConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.RotationConstraint = MRotationConstraint()
                    self.RotationConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.WeightingFactor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MGeometryConstraint')
        if self.ParentObjectID is not None:
            oprot.writeFieldBegin('ParentObjectID', TType.STRING, 1)
            oprot.writeString(self.ParentObjectID.encode('utf-8') if sys.version_info[0] == 2 else self.ParentObjectID)
            oprot.writeFieldEnd()
        if self.ParentToConstraint is not None:
            oprot.writeFieldBegin('ParentToConstraint', TType.STRUCT, 2)
            self.ParentToConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.TranslationConstraint is not None:
            oprot.writeFieldBegin('TranslationConstraint', TType.STRUCT, 3)
            self.TranslationConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.RotationConstraint is not None:
            oprot.writeFieldBegin('RotationConstraint', TType.STRUCT, 4)
            self.RotationConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.WeightingFactor is not None:
            oprot.writeFieldBegin('WeightingFactor', TType.DOUBLE, 5)
            oprot.writeDouble(self.WeightingFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ParentObjectID is None:
            raise TProtocolException(message='Required field ParentObjectID is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MVelocityConstraint(object):
    """
    Attributes:
     - ParentObjectID
     - ParentToConstraint
     - TranslationalVelocity
     - RotationalVelocity
     - WeightingFactor

    """


    def __init__(self, ParentObjectID=None, ParentToConstraint=None, TranslationalVelocity=None, RotationalVelocity=None, WeightingFactor=None,):
        self.ParentObjectID = ParentObjectID
        self.ParentToConstraint = ParentToConstraint
        self.TranslationalVelocity = TranslationalVelocity
        self.RotationalVelocity = RotationalVelocity
        self.WeightingFactor = WeightingFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ParentObjectID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ParentToConstraint = MMIStandard.math.ttypes.MTransform()
                    self.ParentToConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.TranslationalVelocity = MMIStandard.math.ttypes.MVector3()
                    self.TranslationalVelocity.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.RotationalVelocity = MMIStandard.math.ttypes.MVector3()
                    self.RotationalVelocity.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.WeightingFactor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MVelocityConstraint')
        if self.ParentObjectID is not None:
            oprot.writeFieldBegin('ParentObjectID', TType.STRING, 1)
            oprot.writeString(self.ParentObjectID.encode('utf-8') if sys.version_info[0] == 2 else self.ParentObjectID)
            oprot.writeFieldEnd()
        if self.ParentToConstraint is not None:
            oprot.writeFieldBegin('ParentToConstraint', TType.STRUCT, 2)
            self.ParentToConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.TranslationalVelocity is not None:
            oprot.writeFieldBegin('TranslationalVelocity', TType.STRUCT, 3)
            self.TranslationalVelocity.write(oprot)
            oprot.writeFieldEnd()
        if self.RotationalVelocity is not None:
            oprot.writeFieldBegin('RotationalVelocity', TType.STRUCT, 4)
            self.RotationalVelocity.write(oprot)
            oprot.writeFieldEnd()
        if self.WeightingFactor is not None:
            oprot.writeFieldBegin('WeightingFactor', TType.DOUBLE, 5)
            oprot.writeDouble(self.WeightingFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ParentObjectID is None:
            raise TProtocolException(message='Required field ParentObjectID is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MAccelerationConstraint(object):
    """
    Attributes:
     - ParentObjectID
     - ParentToConstraint
     - TranslationalAcceleration
     - RotationalAcceleration
     - WeightingFactor

    """


    def __init__(self, ParentObjectID=None, ParentToConstraint=None, TranslationalAcceleration=None, RotationalAcceleration=None, WeightingFactor=None,):
        self.ParentObjectID = ParentObjectID
        self.ParentToConstraint = ParentToConstraint
        self.TranslationalAcceleration = TranslationalAcceleration
        self.RotationalAcceleration = RotationalAcceleration
        self.WeightingFactor = WeightingFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ParentObjectID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ParentToConstraint = MMIStandard.math.ttypes.MTransform()
                    self.ParentToConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.TranslationalAcceleration = MMIStandard.math.ttypes.MVector3()
                    self.TranslationalAcceleration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.RotationalAcceleration = MMIStandard.math.ttypes.MVector3()
                    self.RotationalAcceleration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.WeightingFactor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MAccelerationConstraint')
        if self.ParentObjectID is not None:
            oprot.writeFieldBegin('ParentObjectID', TType.STRING, 1)
            oprot.writeString(self.ParentObjectID.encode('utf-8') if sys.version_info[0] == 2 else self.ParentObjectID)
            oprot.writeFieldEnd()
        if self.ParentToConstraint is not None:
            oprot.writeFieldBegin('ParentToConstraint', TType.STRUCT, 2)
            self.ParentToConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.TranslationalAcceleration is not None:
            oprot.writeFieldBegin('TranslationalAcceleration', TType.STRUCT, 3)
            self.TranslationalAcceleration.write(oprot)
            oprot.writeFieldEnd()
        if self.RotationalAcceleration is not None:
            oprot.writeFieldBegin('RotationalAcceleration', TType.STRUCT, 4)
            self.RotationalAcceleration.write(oprot)
            oprot.writeFieldEnd()
        if self.WeightingFactor is not None:
            oprot.writeFieldBegin('WeightingFactor', TType.DOUBLE, 5)
            oprot.writeDouble(self.WeightingFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ParentObjectID is None:
            raise TProtocolException(message='Required field ParentObjectID is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MPathConstraint(object):
    """
    Attributes:
     - PolygonPoints
     - WeightingFactor

    """


    def __init__(self, PolygonPoints=None, WeightingFactor=None,):
        self.PolygonPoints = PolygonPoints
        self.WeightingFactor = WeightingFactor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.PolygonPoints = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = MGeometryConstraint()
                        _elem5.read(iprot)
                        self.PolygonPoints.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.WeightingFactor = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MPathConstraint')
        if self.PolygonPoints is not None:
            oprot.writeFieldBegin('PolygonPoints', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.PolygonPoints))
            for iter6 in self.PolygonPoints:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.WeightingFactor is not None:
            oprot.writeFieldBegin('WeightingFactor', TType.DOUBLE, 2)
            oprot.writeDouble(self.WeightingFactor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.PolygonPoints is None:
            raise TProtocolException(message='Required field PolygonPoints is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MJointConstraint(object):
    """
    Attributes:
     - JointType
     - GeometryConstraint
     - VelocityConstraint
     - AccelerationConstraint

    """


    def __init__(self, JointType=None, GeometryConstraint=None, VelocityConstraint=None, AccelerationConstraint=None,):
        self.JointType = JointType
        self.GeometryConstraint = GeometryConstraint
        self.VelocityConstraint = VelocityConstraint
        self.AccelerationConstraint = AccelerationConstraint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.JointType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.GeometryConstraint = MGeometryConstraint()
                    self.GeometryConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.VelocityConstraint = MVelocityConstraint()
                    self.VelocityConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.AccelerationConstraint = MAccelerationConstraint()
                    self.AccelerationConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MJointConstraint')
        if self.JointType is not None:
            oprot.writeFieldBegin('JointType', TType.I32, 1)
            oprot.writeI32(self.JointType)
            oprot.writeFieldEnd()
        if self.GeometryConstraint is not None:
            oprot.writeFieldBegin('GeometryConstraint', TType.STRUCT, 2)
            self.GeometryConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.VelocityConstraint is not None:
            oprot.writeFieldBegin('VelocityConstraint', TType.STRUCT, 3)
            self.VelocityConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.AccelerationConstraint is not None:
            oprot.writeFieldBegin('AccelerationConstraint', TType.STRUCT, 4)
            self.AccelerationConstraint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.JointType is None:
            raise TProtocolException(message='Required field JointType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MJointPathConstraint(object):
    """
    Attributes:
     - JointType
     - PathConstraint

    """


    def __init__(self, JointType=None, PathConstraint=None,):
        self.JointType = JointType
        self.PathConstraint = PathConstraint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.JointType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.PathConstraint = MPathConstraint()
                    self.PathConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MJointPathConstraint')
        if self.JointType is not None:
            oprot.writeFieldBegin('JointType', TType.I32, 1)
            oprot.writeI32(self.JointType)
            oprot.writeFieldEnd()
        if self.PathConstraint is not None:
            oprot.writeFieldBegin('PathConstraint', TType.STRUCT, 2)
            self.PathConstraint.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.JointType is None:
            raise TProtocolException(message='Required field JointType is unset!')
        if self.PathConstraint is None:
            raise TProtocolException(message='Required field PathConstraint is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MPostureConstraint(object):
    """
    Attributes:
     - posture
     - JointConstraints

    """


    def __init__(self, posture=None, JointConstraints=None,):
        self.posture = posture
        self.JointConstraints = JointConstraints

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.posture = MMIStandard.avatar.ttypes.MAvatarPostureValues()
                    self.posture.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.JointConstraints = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = MJointConstraint()
                        _elem12.read(iprot)
                        self.JointConstraints.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MPostureConstraint')
        if self.posture is not None:
            oprot.writeFieldBegin('posture', TType.STRUCT, 1)
            self.posture.write(oprot)
            oprot.writeFieldEnd()
        if self.JointConstraints is not None:
            oprot.writeFieldBegin('JointConstraints', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.JointConstraints))
            for iter13 in self.JointConstraints:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.posture is None:
            raise TProtocolException(message='Required field posture is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MConstraint(object):
    """
    Attributes:
     - ID
     - GeometryConstraint
     - VelocityConstraint
     - AccelerationConstraint
     - PathConstraint
     - JointPathConstraint
     - PostureConstraint
     - JointConstraint
     - Properties

    """


    def __init__(self, ID=None, GeometryConstraint=None, VelocityConstraint=None, AccelerationConstraint=None, PathConstraint=None, JointPathConstraint=None, PostureConstraint=None, JointConstraint=None, Properties=None,):
        self.ID = ID
        self.GeometryConstraint = GeometryConstraint
        self.VelocityConstraint = VelocityConstraint
        self.AccelerationConstraint = AccelerationConstraint
        self.PathConstraint = PathConstraint
        self.JointPathConstraint = JointPathConstraint
        self.PostureConstraint = PostureConstraint
        self.JointConstraint = JointConstraint
        self.Properties = Properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.GeometryConstraint = MGeometryConstraint()
                    self.GeometryConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.VelocityConstraint = MVelocityConstraint()
                    self.VelocityConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.AccelerationConstraint = MAccelerationConstraint()
                    self.AccelerationConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.PathConstraint = MPathConstraint()
                    self.PathConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.JointPathConstraint = MJointPathConstraint()
                    self.JointPathConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.PostureConstraint = MPostureConstraint()
                    self.PostureConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.JointConstraint = MJointConstraint()
                    self.JointConstraint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.Properties = {}
                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                    for _i18 in range(_size14):
                        _key19 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val20 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.Properties[_key19] = _val20
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MConstraint')
        if self.ID is not None:
            oprot.writeFieldBegin('ID', TType.STRING, 1)
            oprot.writeString(self.ID.encode('utf-8') if sys.version_info[0] == 2 else self.ID)
            oprot.writeFieldEnd()
        if self.GeometryConstraint is not None:
            oprot.writeFieldBegin('GeometryConstraint', TType.STRUCT, 2)
            self.GeometryConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.VelocityConstraint is not None:
            oprot.writeFieldBegin('VelocityConstraint', TType.STRUCT, 3)
            self.VelocityConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.AccelerationConstraint is not None:
            oprot.writeFieldBegin('AccelerationConstraint', TType.STRUCT, 4)
            self.AccelerationConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.PathConstraint is not None:
            oprot.writeFieldBegin('PathConstraint', TType.STRUCT, 5)
            self.PathConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.JointPathConstraint is not None:
            oprot.writeFieldBegin('JointPathConstraint', TType.STRUCT, 6)
            self.JointPathConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.PostureConstraint is not None:
            oprot.writeFieldBegin('PostureConstraint', TType.STRUCT, 7)
            self.PostureConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.JointConstraint is not None:
            oprot.writeFieldBegin('JointConstraint', TType.STRUCT, 8)
            self.JointConstraint.write(oprot)
            oprot.writeFieldEnd()
        if self.Properties is not None:
            oprot.writeFieldBegin('Properties', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.Properties))
            for kiter21, viter22 in self.Properties.items():
                oprot.writeString(kiter21.encode('utf-8') if sys.version_info[0] == 2 else kiter21)
                oprot.writeString(viter22.encode('utf-8') if sys.version_info[0] == 2 else viter22)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ID is None:
            raise TProtocolException(message='Required field ID is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(MInterval)
MInterval.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'Min', None, None, ),  # 1
    (2, TType.DOUBLE, 'Max', None, None, ),  # 2
)
all_structs.append(MInterval3)
MInterval3.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'X', [MInterval, None], None, ),  # 1
    (2, TType.STRUCT, 'Y', [MInterval, None], None, ),  # 2
    (3, TType.STRUCT, 'Z', [MInterval, None], None, ),  # 3
)
all_structs.append(MTranslationConstraint)
MTranslationConstraint.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'Type', None, None, ),  # 1
    (2, TType.STRUCT, 'Limits', [MInterval3, None], None, ),  # 2
)
all_structs.append(MRotationConstraint)
MRotationConstraint.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.STRUCT, 'Limits', [MInterval3, None], None, ),  # 2
)
all_structs.append(MGeometryConstraint)
MGeometryConstraint.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ParentObjectID', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'ParentToConstraint', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 2
    (3, TType.STRUCT, 'TranslationConstraint', [MTranslationConstraint, None], None, ),  # 3
    (4, TType.STRUCT, 'RotationConstraint', [MRotationConstraint, None], None, ),  # 4
    (5, TType.DOUBLE, 'WeightingFactor', None, None, ),  # 5
)
all_structs.append(MVelocityConstraint)
MVelocityConstraint.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ParentObjectID', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'ParentToConstraint', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 2
    (3, TType.STRUCT, 'TranslationalVelocity', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 3
    (4, TType.STRUCT, 'RotationalVelocity', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 4
    (5, TType.DOUBLE, 'WeightingFactor', None, None, ),  # 5
)
all_structs.append(MAccelerationConstraint)
MAccelerationConstraint.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ParentObjectID', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'ParentToConstraint', [MMIStandard.math.ttypes.MTransform, None], None, ),  # 2
    (3, TType.STRUCT, 'TranslationalAcceleration', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 3
    (4, TType.STRUCT, 'RotationalAcceleration', [MMIStandard.math.ttypes.MVector3, None], None, ),  # 4
    (5, TType.DOUBLE, 'WeightingFactor', None, None, ),  # 5
)
all_structs.append(MPathConstraint)
MPathConstraint.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'PolygonPoints', (TType.STRUCT, [MGeometryConstraint, None], False), None, ),  # 1
    (2, TType.DOUBLE, 'WeightingFactor', None, None, ),  # 2
)
all_structs.append(MJointConstraint)
MJointConstraint.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'JointType', None, None, ),  # 1
    (2, TType.STRUCT, 'GeometryConstraint', [MGeometryConstraint, None], None, ),  # 2
    (3, TType.STRUCT, 'VelocityConstraint', [MVelocityConstraint, None], None, ),  # 3
    (4, TType.STRUCT, 'AccelerationConstraint', [MAccelerationConstraint, None], None, ),  # 4
)
all_structs.append(MJointPathConstraint)
MJointPathConstraint.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'JointType', None, None, ),  # 1
    (2, TType.STRUCT, 'PathConstraint', [MPathConstraint, None], None, ),  # 2
)
all_structs.append(MPostureConstraint)
MPostureConstraint.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'posture', [MMIStandard.avatar.ttypes.MAvatarPostureValues, None], None, ),  # 1
    (2, TType.LIST, 'JointConstraints', (TType.STRUCT, [MJointConstraint, None], False), None, ),  # 2
)
all_structs.append(MConstraint)
MConstraint.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ID', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'GeometryConstraint', [MGeometryConstraint, None], None, ),  # 2
    (3, TType.STRUCT, 'VelocityConstraint', [MVelocityConstraint, None], None, ),  # 3
    (4, TType.STRUCT, 'AccelerationConstraint', [MAccelerationConstraint, None], None, ),  # 4
    (5, TType.STRUCT, 'PathConstraint', [MPathConstraint, None], None, ),  # 5
    (6, TType.STRUCT, 'JointPathConstraint', [MJointPathConstraint, None], None, ),  # 6
    (7, TType.STRUCT, 'PostureConstraint', [MPostureConstraint, None], None, ),  # 7
    (8, TType.STRUCT, 'JointConstraint', [MJointConstraint, None], None, ),  # 8
    (9, TType.MAP, 'Properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 9
)
fix_spec(all_structs)
del all_structs
