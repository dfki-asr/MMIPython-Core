#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def Initialize(self, avatarDescription, properties, mmuID, sessionID):
        """
        Parameters:
         - avatarDescription
         - properties
         - mmuID
         - sessionID

        """
        pass

    def AssignInstruction(self, instruction, simulationState, mmuID, sessionID):
        """
        Parameters:
         - instruction
         - simulationState
         - mmuID
         - sessionID

        """
        pass

    def DoStep(self, time, simulationState, mmuID, sessionID):
        """
        Parameters:
         - time
         - simulationState
         - mmuID
         - sessionID

        """
        pass

    def GetBoundaryConstraints(self, instruction, mmuID, sessionID):
        """
        Parameters:
         - instruction
         - mmuID
         - sessionID

        """
        pass

    def CheckPrerequisites(self, instruction, mmuID, sessionID):
        """
        Parameters:
         - instruction
         - mmuID
         - sessionID

        """
        pass

    def Abort(self, instructionID, mmuID, sessionID):
        """
        Parameters:
         - instructionID
         - mmuID
         - sessionID

        """
        pass

    def Dispose(self, mmuID, sessionID, avatarID):
        """
        Parameters:
         - mmuID
         - sessionID
         - avatarID

        """
        pass

    def ExecuteFunction(self, name, parameters, mmuID, sessionID, avatarID):
        """
        Parameters:
         - name
         - parameters
         - mmuID
         - sessionID
         - avatarID

        """
        pass

    def GetStatus(self):
        pass

    def GetAdapterDescription(self):
        pass

    def CreateSession(self, sessionID, sceneID):
        """
        Parameters:
         - sessionID
         - sceneID

        """
        pass

    def CloseSession(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        pass

    def PushScene(self, sceneUpdates, sessionID):
        """
        Parameters:
         - sceneUpdates
         - sessionID

        """
        pass

    def GetLoadableMMUs(self):
        pass

    def GetMMus(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        pass

    def GetDescription(self, mmuID, sessionID):
        """
        Parameters:
         - mmuID
         - sessionID

        """
        pass

    def GetScene(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        pass

    def GetSceneChanges(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        pass

    def LoadMMUs(self, mmus, sessionID):
        """
        Parameters:
         - mmus
         - sessionID

        """
        pass

    def CreateCheckpoint(self, mmuID, sessionID):
        """
        Parameters:
         - mmuID
         - sessionID

        """
        pass

    def RestoreCheckpoint(self, mmuID, sessionID, checkpointData):
        """
        Parameters:
         - mmuID
         - sessionID
         - checkpointData

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def Initialize(self, avatarDescription, properties, mmuID, sessionID):
        """
        Parameters:
         - avatarDescription
         - properties
         - mmuID
         - sessionID

        """
        self.send_Initialize(avatarDescription, properties, mmuID, sessionID)
        return self.recv_Initialize()

    def send_Initialize(self, avatarDescription, properties, mmuID, sessionID):
        self._oprot.writeMessageBegin('Initialize', TMessageType.CALL, self._seqid)
        args = Initialize_args()
        args.avatarDescription = avatarDescription
        args.properties = properties
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Initialize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Initialize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "Initialize failed: unknown result")

    def AssignInstruction(self, instruction, simulationState, mmuID, sessionID):
        """
        Parameters:
         - instruction
         - simulationState
         - mmuID
         - sessionID

        """
        self.send_AssignInstruction(instruction, simulationState, mmuID, sessionID)
        return self.recv_AssignInstruction()

    def send_AssignInstruction(self, instruction, simulationState, mmuID, sessionID):
        self._oprot.writeMessageBegin('AssignInstruction', TMessageType.CALL, self._seqid)
        args = AssignInstruction_args()
        args.instruction = instruction
        args.simulationState = simulationState
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_AssignInstruction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = AssignInstruction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "AssignInstruction failed: unknown result")

    def DoStep(self, time, simulationState, mmuID, sessionID):
        """
        Parameters:
         - time
         - simulationState
         - mmuID
         - sessionID

        """
        self.send_DoStep(time, simulationState, mmuID, sessionID)
        return self.recv_DoStep()

    def send_DoStep(self, time, simulationState, mmuID, sessionID):
        self._oprot.writeMessageBegin('DoStep', TMessageType.CALL, self._seqid)
        args = DoStep_args()
        args.time = time
        args.simulationState = simulationState
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_DoStep(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = DoStep_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "DoStep failed: unknown result")

    def GetBoundaryConstraints(self, instruction, mmuID, sessionID):
        """
        Parameters:
         - instruction
         - mmuID
         - sessionID

        """
        self.send_GetBoundaryConstraints(instruction, mmuID, sessionID)
        return self.recv_GetBoundaryConstraints()

    def send_GetBoundaryConstraints(self, instruction, mmuID, sessionID):
        self._oprot.writeMessageBegin('GetBoundaryConstraints', TMessageType.CALL, self._seqid)
        args = GetBoundaryConstraints_args()
        args.instruction = instruction
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetBoundaryConstraints(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetBoundaryConstraints_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetBoundaryConstraints failed: unknown result")

    def CheckPrerequisites(self, instruction, mmuID, sessionID):
        """
        Parameters:
         - instruction
         - mmuID
         - sessionID

        """
        self.send_CheckPrerequisites(instruction, mmuID, sessionID)
        return self.recv_CheckPrerequisites()

    def send_CheckPrerequisites(self, instruction, mmuID, sessionID):
        self._oprot.writeMessageBegin('CheckPrerequisites', TMessageType.CALL, self._seqid)
        args = CheckPrerequisites_args()
        args.instruction = instruction
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CheckPrerequisites(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CheckPrerequisites_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CheckPrerequisites failed: unknown result")

    def Abort(self, instructionID, mmuID, sessionID):
        """
        Parameters:
         - instructionID
         - mmuID
         - sessionID

        """
        self.send_Abort(instructionID, mmuID, sessionID)
        return self.recv_Abort()

    def send_Abort(self, instructionID, mmuID, sessionID):
        self._oprot.writeMessageBegin('Abort', TMessageType.CALL, self._seqid)
        args = Abort_args()
        args.instructionID = instructionID
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Abort(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Abort_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "Abort failed: unknown result")

    def Dispose(self, mmuID, sessionID, avatarID):
        """
        Parameters:
         - mmuID
         - sessionID
         - avatarID

        """
        self.send_Dispose(mmuID, sessionID, avatarID)
        return self.recv_Dispose()

    def send_Dispose(self, mmuID, sessionID, avatarID):
        self._oprot.writeMessageBegin('Dispose', TMessageType.CALL, self._seqid)
        args = Dispose_args()
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.avatarID = avatarID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_Dispose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = Dispose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "Dispose failed: unknown result")

    def ExecuteFunction(self, name, parameters, mmuID, sessionID, avatarID):
        """
        Parameters:
         - name
         - parameters
         - mmuID
         - sessionID
         - avatarID

        """
        self.send_ExecuteFunction(name, parameters, mmuID, sessionID, avatarID)
        return self.recv_ExecuteFunction()

    def send_ExecuteFunction(self, name, parameters, mmuID, sessionID, avatarID):
        self._oprot.writeMessageBegin('ExecuteFunction', TMessageType.CALL, self._seqid)
        args = ExecuteFunction_args()
        args.name = name
        args.parameters = parameters
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.avatarID = avatarID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ExecuteFunction(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ExecuteFunction_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "ExecuteFunction failed: unknown result")

    def GetStatus(self):
        self.send_GetStatus()
        return self.recv_GetStatus()

    def send_GetStatus(self):
        self._oprot.writeMessageBegin('GetStatus', TMessageType.CALL, self._seqid)
        args = GetStatus_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetStatus failed: unknown result")

    def GetAdapterDescription(self):
        self.send_GetAdapterDescription()
        return self.recv_GetAdapterDescription()

    def send_GetAdapterDescription(self):
        self._oprot.writeMessageBegin('GetAdapterDescription', TMessageType.CALL, self._seqid)
        args = GetAdapterDescription_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetAdapterDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetAdapterDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetAdapterDescription failed: unknown result")

    def CreateSession(self, sessionID, sceneID):
        """
        Parameters:
         - sessionID
         - sceneID

        """
        self.send_CreateSession(sessionID, sceneID)
        return self.recv_CreateSession()

    def send_CreateSession(self, sessionID, sceneID):
        self._oprot.writeMessageBegin('CreateSession', TMessageType.CALL, self._seqid)
        args = CreateSession_args()
        args.sessionID = sessionID
        args.sceneID = sceneID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateSession(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateSession failed: unknown result")

    def CloseSession(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        self.send_CloseSession(sessionID)
        return self.recv_CloseSession()

    def send_CloseSession(self, sessionID):
        self._oprot.writeMessageBegin('CloseSession', TMessageType.CALL, self._seqid)
        args = CloseSession_args()
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CloseSession(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CloseSession_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CloseSession failed: unknown result")

    def PushScene(self, sceneUpdates, sessionID):
        """
        Parameters:
         - sceneUpdates
         - sessionID

        """
        self.send_PushScene(sceneUpdates, sessionID)
        return self.recv_PushScene()

    def send_PushScene(self, sceneUpdates, sessionID):
        self._oprot.writeMessageBegin('PushScene', TMessageType.CALL, self._seqid)
        args = PushScene_args()
        args.sceneUpdates = sceneUpdates
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_PushScene(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = PushScene_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "PushScene failed: unknown result")

    def GetLoadableMMUs(self):
        self.send_GetLoadableMMUs()
        return self.recv_GetLoadableMMUs()

    def send_GetLoadableMMUs(self):
        self._oprot.writeMessageBegin('GetLoadableMMUs', TMessageType.CALL, self._seqid)
        args = GetLoadableMMUs_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetLoadableMMUs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetLoadableMMUs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetLoadableMMUs failed: unknown result")

    def GetMMus(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        self.send_GetMMus(sessionID)
        return self.recv_GetMMus()

    def send_GetMMus(self, sessionID):
        self._oprot.writeMessageBegin('GetMMus', TMessageType.CALL, self._seqid)
        args = GetMMus_args()
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetMMus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetMMus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetMMus failed: unknown result")

    def GetDescription(self, mmuID, sessionID):
        """
        Parameters:
         - mmuID
         - sessionID

        """
        self.send_GetDescription(mmuID, sessionID)
        return self.recv_GetDescription()

    def send_GetDescription(self, mmuID, sessionID):
        self._oprot.writeMessageBegin('GetDescription', TMessageType.CALL, self._seqid)
        args = GetDescription_args()
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetDescription(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetDescription_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetDescription failed: unknown result")

    def GetScene(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        self.send_GetScene(sessionID)
        return self.recv_GetScene()

    def send_GetScene(self, sessionID):
        self._oprot.writeMessageBegin('GetScene', TMessageType.CALL, self._seqid)
        args = GetScene_args()
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetScene(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetScene_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetScene failed: unknown result")

    def GetSceneChanges(self, sessionID):
        """
        Parameters:
         - sessionID

        """
        self.send_GetSceneChanges(sessionID)
        return self.recv_GetSceneChanges()

    def send_GetSceneChanges(self, sessionID):
        self._oprot.writeMessageBegin('GetSceneChanges', TMessageType.CALL, self._seqid)
        args = GetSceneChanges_args()
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_GetSceneChanges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = GetSceneChanges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "GetSceneChanges failed: unknown result")

    def LoadMMUs(self, mmus, sessionID):
        """
        Parameters:
         - mmus
         - sessionID

        """
        self.send_LoadMMUs(mmus, sessionID)
        return self.recv_LoadMMUs()

    def send_LoadMMUs(self, mmus, sessionID):
        self._oprot.writeMessageBegin('LoadMMUs', TMessageType.CALL, self._seqid)
        args = LoadMMUs_args()
        args.mmus = mmus
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_LoadMMUs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = LoadMMUs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "LoadMMUs failed: unknown result")

    def CreateCheckpoint(self, mmuID, sessionID):
        """
        Parameters:
         - mmuID
         - sessionID

        """
        self.send_CreateCheckpoint(mmuID, sessionID)
        return self.recv_CreateCheckpoint()

    def send_CreateCheckpoint(self, mmuID, sessionID):
        self._oprot.writeMessageBegin('CreateCheckpoint', TMessageType.CALL, self._seqid)
        args = CreateCheckpoint_args()
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_CreateCheckpoint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = CreateCheckpoint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "CreateCheckpoint failed: unknown result")

    def RestoreCheckpoint(self, mmuID, sessionID, checkpointData):
        """
        Parameters:
         - mmuID
         - sessionID
         - checkpointData

        """
        self.send_RestoreCheckpoint(mmuID, sessionID, checkpointData)
        return self.recv_RestoreCheckpoint()

    def send_RestoreCheckpoint(self, mmuID, sessionID, checkpointData):
        self._oprot.writeMessageBegin('RestoreCheckpoint', TMessageType.CALL, self._seqid)
        args = RestoreCheckpoint_args()
        args.mmuID = mmuID
        args.sessionID = sessionID
        args.checkpointData = checkpointData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_RestoreCheckpoint(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = RestoreCheckpoint_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "RestoreCheckpoint failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["Initialize"] = Processor.process_Initialize
        self._processMap["AssignInstruction"] = Processor.process_AssignInstruction
        self._processMap["DoStep"] = Processor.process_DoStep
        self._processMap["GetBoundaryConstraints"] = Processor.process_GetBoundaryConstraints
        self._processMap["CheckPrerequisites"] = Processor.process_CheckPrerequisites
        self._processMap["Abort"] = Processor.process_Abort
        self._processMap["Dispose"] = Processor.process_Dispose
        self._processMap["ExecuteFunction"] = Processor.process_ExecuteFunction
        self._processMap["GetStatus"] = Processor.process_GetStatus
        self._processMap["GetAdapterDescription"] = Processor.process_GetAdapterDescription
        self._processMap["CreateSession"] = Processor.process_CreateSession
        self._processMap["CloseSession"] = Processor.process_CloseSession
        self._processMap["PushScene"] = Processor.process_PushScene
        self._processMap["GetLoadableMMUs"] = Processor.process_GetLoadableMMUs
        self._processMap["GetMMus"] = Processor.process_GetMMus
        self._processMap["GetDescription"] = Processor.process_GetDescription
        self._processMap["GetScene"] = Processor.process_GetScene
        self._processMap["GetSceneChanges"] = Processor.process_GetSceneChanges
        self._processMap["LoadMMUs"] = Processor.process_LoadMMUs
        self._processMap["CreateCheckpoint"] = Processor.process_CreateCheckpoint
        self._processMap["RestoreCheckpoint"] = Processor.process_RestoreCheckpoint
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_Initialize(self, seqid, iprot, oprot):
        args = Initialize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Initialize_result()
        try:
            result.success = self._handler.Initialize(args.avatarDescription, args.properties, args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Initialize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_AssignInstruction(self, seqid, iprot, oprot):
        args = AssignInstruction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = AssignInstruction_result()
        try:
            result.success = self._handler.AssignInstruction(args.instruction, args.simulationState, args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("AssignInstruction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_DoStep(self, seqid, iprot, oprot):
        args = DoStep_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = DoStep_result()
        try:
            result.success = self._handler.DoStep(args.time, args.simulationState, args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("DoStep", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetBoundaryConstraints(self, seqid, iprot, oprot):
        args = GetBoundaryConstraints_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetBoundaryConstraints_result()
        try:
            result.success = self._handler.GetBoundaryConstraints(args.instruction, args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetBoundaryConstraints", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CheckPrerequisites(self, seqid, iprot, oprot):
        args = CheckPrerequisites_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CheckPrerequisites_result()
        try:
            result.success = self._handler.CheckPrerequisites(args.instruction, args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CheckPrerequisites", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Abort(self, seqid, iprot, oprot):
        args = Abort_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Abort_result()
        try:
            result.success = self._handler.Abort(args.instructionID, args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Abort", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_Dispose(self, seqid, iprot, oprot):
        args = Dispose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Dispose_result()
        try:
            result.success = self._handler.Dispose(args.mmuID, args.sessionID, args.avatarID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("Dispose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_ExecuteFunction(self, seqid, iprot, oprot):
        args = ExecuteFunction_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ExecuteFunction_result()
        try:
            result.success = self._handler.ExecuteFunction(args.name, args.parameters, args.mmuID, args.sessionID, args.avatarID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ExecuteFunction", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetStatus(self, seqid, iprot, oprot):
        args = GetStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetStatus_result()
        try:
            result.success = self._handler.GetStatus()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetAdapterDescription(self, seqid, iprot, oprot):
        args = GetAdapterDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetAdapterDescription_result()
        try:
            result.success = self._handler.GetAdapterDescription()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetAdapterDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateSession(self, seqid, iprot, oprot):
        args = CreateSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateSession_result()
        try:
            result.success = self._handler.CreateSession(args.sessionID, args.sceneID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CloseSession(self, seqid, iprot, oprot):
        args = CloseSession_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CloseSession_result()
        try:
            result.success = self._handler.CloseSession(args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CloseSession", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_PushScene(self, seqid, iprot, oprot):
        args = PushScene_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = PushScene_result()
        try:
            result.success = self._handler.PushScene(args.sceneUpdates, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("PushScene", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetLoadableMMUs(self, seqid, iprot, oprot):
        args = GetLoadableMMUs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetLoadableMMUs_result()
        try:
            result.success = self._handler.GetLoadableMMUs()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetLoadableMMUs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetMMus(self, seqid, iprot, oprot):
        args = GetMMus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetMMus_result()
        try:
            result.success = self._handler.GetMMus(args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetMMus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetDescription(self, seqid, iprot, oprot):
        args = GetDescription_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetDescription_result()
        try:
            result.success = self._handler.GetDescription(args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetDescription", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetScene(self, seqid, iprot, oprot):
        args = GetScene_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetScene_result()
        try:
            result.success = self._handler.GetScene(args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetScene", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_GetSceneChanges(self, seqid, iprot, oprot):
        args = GetSceneChanges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = GetSceneChanges_result()
        try:
            result.success = self._handler.GetSceneChanges(args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("GetSceneChanges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_LoadMMUs(self, seqid, iprot, oprot):
        args = LoadMMUs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = LoadMMUs_result()
        try:
            result.success = self._handler.LoadMMUs(args.mmus, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("LoadMMUs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_CreateCheckpoint(self, seqid, iprot, oprot):
        args = CreateCheckpoint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = CreateCheckpoint_result()
        try:
            result.success = self._handler.CreateCheckpoint(args.mmuID, args.sessionID)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("CreateCheckpoint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_RestoreCheckpoint(self, seqid, iprot, oprot):
        args = RestoreCheckpoint_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = RestoreCheckpoint_result()
        try:
            result.success = self._handler.RestoreCheckpoint(args.mmuID, args.sessionID, args.checkpointData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("RestoreCheckpoint", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class Initialize_args(object):
    """
    Attributes:
     - avatarDescription
     - properties
     - mmuID
     - sessionID

    """


    def __init__(self, avatarDescription=None, properties=None, mmuID=None, sessionID=None,):
        self.avatarDescription = avatarDescription
        self.properties = properties
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.avatarDescription = MMIStandard.avatar.ttypes.MAvatarDescription()
                    self.avatarDescription.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val29 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.properties[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Initialize_args')
        if self.avatarDescription is not None:
            oprot.writeFieldBegin('avatarDescription', TType.STRUCT, 1)
            self.avatarDescription.write(oprot)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter30, viter31 in self.properties.items():
                oprot.writeString(kiter30.encode('utf-8') if sys.version_info[0] == 2 else kiter30)
                oprot.writeString(viter31.encode('utf-8') if sys.version_info[0] == 2 else viter31)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 3)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 4)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Initialize_args)
Initialize_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'avatarDescription', [MMIStandard.avatar.ttypes.MAvatarDescription, None], None, ),  # 1
    (2, TType.MAP, 'properties', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'mmuID', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'sessionID', 'UTF8', None, ),  # 4
)


class Initialize_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Initialize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Initialize_result)
Initialize_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class AssignInstruction_args(object):
    """
    Attributes:
     - instruction
     - simulationState
     - mmuID
     - sessionID

    """


    def __init__(self, instruction=None, simulationState=None, mmuID=None, sessionID=None,):
        self.instruction = instruction
        self.simulationState = simulationState
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.instruction = MMIStandard.mmu.ttypes.MInstruction()
                    self.instruction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.simulationState = MMIStandard.mmu.ttypes.MSimulationState()
                    self.simulationState.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AssignInstruction_args')
        if self.instruction is not None:
            oprot.writeFieldBegin('instruction', TType.STRUCT, 1)
            self.instruction.write(oprot)
            oprot.writeFieldEnd()
        if self.simulationState is not None:
            oprot.writeFieldBegin('simulationState', TType.STRUCT, 2)
            self.simulationState.write(oprot)
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 3)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 4)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AssignInstruction_args)
AssignInstruction_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'instruction', [MMIStandard.mmu.ttypes.MInstruction, None], None, ),  # 1
    (2, TType.STRUCT, 'simulationState', [MMIStandard.mmu.ttypes.MSimulationState, None], None, ),  # 2
    (3, TType.STRING, 'mmuID', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'sessionID', 'UTF8', None, ),  # 4
)


class AssignInstruction_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AssignInstruction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(AssignInstruction_result)
AssignInstruction_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class DoStep_args(object):
    """
    Attributes:
     - time
     - simulationState
     - mmuID
     - sessionID

    """


    def __init__(self, time=None, simulationState=None, mmuID=None, sessionID=None,):
        self.time = time
        self.simulationState = simulationState
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.simulationState = MMIStandard.mmu.ttypes.MSimulationState()
                    self.simulationState.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DoStep_args')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.DOUBLE, 1)
            oprot.writeDouble(self.time)
            oprot.writeFieldEnd()
        if self.simulationState is not None:
            oprot.writeFieldBegin('simulationState', TType.STRUCT, 2)
            self.simulationState.write(oprot)
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 3)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 4)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DoStep_args)
DoStep_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'time', None, None, ),  # 1
    (2, TType.STRUCT, 'simulationState', [MMIStandard.mmu.ttypes.MSimulationState, None], None, ),  # 2
    (3, TType.STRING, 'mmuID', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'sessionID', 'UTF8', None, ),  # 4
)


class DoStep_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.mmu.ttypes.MSimulationResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DoStep_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(DoStep_result)
DoStep_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.mmu.ttypes.MSimulationResult, None], None, ),  # 0
)


class GetBoundaryConstraints_args(object):
    """
    Attributes:
     - instruction
     - mmuID
     - sessionID

    """


    def __init__(self, instruction=None, mmuID=None, sessionID=None,):
        self.instruction = instruction
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.instruction = MMIStandard.mmu.ttypes.MInstruction()
                    self.instruction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBoundaryConstraints_args')
        if self.instruction is not None:
            oprot.writeFieldBegin('instruction', TType.STRUCT, 1)
            self.instruction.write(oprot)
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 2)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 3)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetBoundaryConstraints_args)
GetBoundaryConstraints_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'instruction', [MMIStandard.mmu.ttypes.MInstruction, None], None, ),  # 1
    (2, TType.STRING, 'mmuID', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'sessionID', 'UTF8', None, ),  # 3
)


class GetBoundaryConstraints_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = MMIStandard.constraints.ttypes.MConstraint()
                        _elem37.read(iprot)
                        self.success.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetBoundaryConstraints_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter38 in self.success:
                iter38.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetBoundaryConstraints_result)
GetBoundaryConstraints_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MMIStandard.constraints.ttypes.MConstraint, None], False), None, ),  # 0
)


class CheckPrerequisites_args(object):
    """
    Attributes:
     - instruction
     - mmuID
     - sessionID

    """


    def __init__(self, instruction=None, mmuID=None, sessionID=None,):
        self.instruction = instruction
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.instruction = MMIStandard.mmu.ttypes.MInstruction()
                    self.instruction.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckPrerequisites_args')
        if self.instruction is not None:
            oprot.writeFieldBegin('instruction', TType.STRUCT, 1)
            self.instruction.write(oprot)
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 2)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 3)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckPrerequisites_args)
CheckPrerequisites_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'instruction', [MMIStandard.mmu.ttypes.MInstruction, None], None, ),  # 1
    (2, TType.STRING, 'mmuID', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'sessionID', 'UTF8', None, ),  # 3
)


class CheckPrerequisites_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CheckPrerequisites_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CheckPrerequisites_result)
CheckPrerequisites_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class Abort_args(object):
    """
    Attributes:
     - instructionID
     - mmuID
     - sessionID

    """


    def __init__(self, instructionID=None, mmuID=None, sessionID=None,):
        self.instructionID = instructionID
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.instructionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Abort_args')
        if self.instructionID is not None:
            oprot.writeFieldBegin('instructionID', TType.STRING, 1)
            oprot.writeString(self.instructionID.encode('utf-8') if sys.version_info[0] == 2 else self.instructionID)
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 2)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 3)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Abort_args)
Abort_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'instructionID', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'mmuID', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'sessionID', 'UTF8', None, ),  # 3
)


class Abort_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Abort_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Abort_result)
Abort_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class Dispose_args(object):
    """
    Attributes:
     - mmuID
     - sessionID
     - avatarID

    """


    def __init__(self, mmuID=None, sessionID=None, avatarID=None,):
        self.mmuID = mmuID
        self.sessionID = sessionID
        self.avatarID = avatarID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.avatarID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Dispose_args')
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 1)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 2)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        if self.avatarID is not None:
            oprot.writeFieldBegin('avatarID', TType.STRING, 3)
            oprot.writeString(self.avatarID.encode('utf-8') if sys.version_info[0] == 2 else self.avatarID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Dispose_args)
Dispose_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'mmuID', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sessionID', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'avatarID', 'UTF8', None, ),  # 3
)


class Dispose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Dispose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Dispose_result)
Dispose_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class ExecuteFunction_args(object):
    """
    Attributes:
     - name
     - parameters
     - mmuID
     - sessionID
     - avatarID

    """


    def __init__(self, name=None, parameters=None, mmuID=None, sessionID=None, avatarID=None,):
        self.name = name
        self.parameters = parameters
        self.mmuID = mmuID
        self.sessionID = sessionID
        self.avatarID = avatarID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.parameters = {}
                    (_ktype40, _vtype41, _size39) = iprot.readMapBegin()
                    for _i43 in range(_size39):
                        _key44 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val45 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameters[_key44] = _val45
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.avatarID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteFunction_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.parameters is not None:
            oprot.writeFieldBegin('parameters', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameters))
            for kiter46, viter47 in self.parameters.items():
                oprot.writeString(kiter46.encode('utf-8') if sys.version_info[0] == 2 else kiter46)
                oprot.writeString(viter47.encode('utf-8') if sys.version_info[0] == 2 else viter47)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 3)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 4)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        if self.avatarID is not None:
            oprot.writeFieldBegin('avatarID', TType.STRING, 5)
            oprot.writeString(self.avatarID.encode('utf-8') if sys.version_info[0] == 2 else self.avatarID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExecuteFunction_args)
ExecuteFunction_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'parameters', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'mmuID', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'sessionID', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'avatarID', 'UTF8', None, ),  # 5
)


class ExecuteFunction_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype49, _vtype50, _size48) = iprot.readMapBegin()
                    for _i52 in range(_size48):
                        _key53 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val54 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key53] = _val54
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExecuteFunction_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter55, viter56 in self.success.items():
                oprot.writeString(kiter55.encode('utf-8') if sys.version_info[0] == 2 else kiter55)
                oprot.writeString(viter56.encode('utf-8') if sys.version_info[0] == 2 else viter56)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ExecuteFunction_result)
ExecuteFunction_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class GetStatus_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatus_args)
GetStatus_args.thrift_spec = (
)


class GetStatus_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype58, _vtype59, _size57) = iprot.readMapBegin()
                    for _i61 in range(_size57):
                        _key62 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val63 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key62] = _val63
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter64, viter65 in self.success.items():
                oprot.writeString(kiter64.encode('utf-8') if sys.version_info[0] == 2 else kiter64)
                oprot.writeString(viter65.encode('utf-8') if sys.version_info[0] == 2 else viter65)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetStatus_result)
GetStatus_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class GetAdapterDescription_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAdapterDescription_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAdapterDescription_args)
GetAdapterDescription_args.thrift_spec = (
)


class GetAdapterDescription_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MAdapterDescription()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetAdapterDescription_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetAdapterDescription_result)
GetAdapterDescription_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MAdapterDescription, None], None, ),  # 0
)


class CreateSession_args(object):
    """
    Attributes:
     - sessionID
     - sceneID

    """


    def __init__(self, sessionID=None, sceneID=None,):
        self.sessionID = sessionID
        self.sceneID = sceneID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sceneID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateSession_args')
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 1)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        if self.sceneID is not None:
            oprot.writeFieldBegin('sceneID', TType.STRING, 2)
            oprot.writeString(self.sceneID.encode('utf-8') if sys.version_info[0] == 2 else self.sceneID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateSession_args)
CreateSession_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionID', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sceneID', 'UTF8', None, ),  # 2
)


class CreateSession_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateSession_result)
CreateSession_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class CloseSession_args(object):
    """
    Attributes:
     - sessionID

    """


    def __init__(self, sessionID=None,):
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CloseSession_args')
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 1)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CloseSession_args)
CloseSession_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionID', 'UTF8', None, ),  # 1
)


class CloseSession_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CloseSession_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CloseSession_result)
CloseSession_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class PushScene_args(object):
    """
    Attributes:
     - sceneUpdates
     - sessionID

    """


    def __init__(self, sceneUpdates=None, sessionID=None,):
        self.sceneUpdates = sceneUpdates
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sceneUpdates = MMIStandard.scene.ttypes.MSceneUpdate()
                    self.sceneUpdates.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PushScene_args')
        if self.sceneUpdates is not None:
            oprot.writeFieldBegin('sceneUpdates', TType.STRUCT, 1)
            self.sceneUpdates.write(oprot)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 2)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PushScene_args)
PushScene_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sceneUpdates', [MMIStandard.scene.ttypes.MSceneUpdate, None], None, ),  # 1
    (2, TType.STRING, 'sessionID', 'UTF8', None, ),  # 2
)


class PushScene_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PushScene_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(PushScene_result)
PushScene_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)


class GetLoadableMMUs_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLoadableMMUs_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLoadableMMUs_args)
GetLoadableMMUs_args.thrift_spec = (
)


class GetLoadableMMUs_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype69, _size66) = iprot.readListBegin()
                    for _i70 in range(_size66):
                        _elem71 = MMIStandard.mmu.ttypes.MMUDescription()
                        _elem71.read(iprot)
                        self.success.append(_elem71)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetLoadableMMUs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter72 in self.success:
                iter72.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetLoadableMMUs_result)
GetLoadableMMUs_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MMIStandard.mmu.ttypes.MMUDescription, None], False), None, ),  # 0
)


class GetMMus_args(object):
    """
    Attributes:
     - sessionID

    """


    def __init__(self, sessionID=None,):
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMMus_args')
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 1)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetMMus_args)
GetMMus_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionID', 'UTF8', None, ),  # 1
)


class GetMMus_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = MMIStandard.mmu.ttypes.MMUDescription()
                        _elem78.read(iprot)
                        self.success.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetMMus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter79 in self.success:
                iter79.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetMMus_result)
GetMMus_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MMIStandard.mmu.ttypes.MMUDescription, None], False), None, ),  # 0
)


class GetDescription_args(object):
    """
    Attributes:
     - mmuID
     - sessionID

    """


    def __init__(self, mmuID=None, sessionID=None,):
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDescription_args')
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 1)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 2)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetDescription_args)
GetDescription_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'mmuID', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sessionID', 'UTF8', None, ),  # 2
)


class GetDescription_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.mmu.ttypes.MMUDescription()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetDescription_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetDescription_result)
GetDescription_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.mmu.ttypes.MMUDescription, None], None, ),  # 0
)


class GetScene_args(object):
    """
    Attributes:
     - sessionID

    """


    def __init__(self, sessionID=None,):
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetScene_args')
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 1)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetScene_args)
GetScene_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionID', 'UTF8', None, ),  # 1
)


class GetScene_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype83, _size80) = iprot.readListBegin()
                    for _i84 in range(_size80):
                        _elem85 = MMIStandard.scene.ttypes.MSceneObject()
                        _elem85.read(iprot)
                        self.success.append(_elem85)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetScene_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter86 in self.success:
                iter86.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetScene_result)
GetScene_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MMIStandard.scene.ttypes.MSceneObject, None], False), None, ),  # 0
)


class GetSceneChanges_args(object):
    """
    Attributes:
     - sessionID

    """


    def __init__(self, sessionID=None,):
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSceneChanges_args')
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 1)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSceneChanges_args)
GetSceneChanges_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionID', 'UTF8', None, ),  # 1
)


class GetSceneChanges_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.scene.ttypes.MSceneUpdate()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetSceneChanges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(GetSceneChanges_result)
GetSceneChanges_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.scene.ttypes.MSceneUpdate, None], None, ),  # 0
)


class LoadMMUs_args(object):
    """
    Attributes:
     - mmus
     - sessionID

    """


    def __init__(self, mmus=None, sessionID=None,):
        self.mmus = mmus
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.mmus = []
                    (_etype90, _size87) = iprot.readListBegin()
                    for _i91 in range(_size87):
                        _elem92 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.mmus.append(_elem92)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadMMUs_args')
        if self.mmus is not None:
            oprot.writeFieldBegin('mmus', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.mmus))
            for iter93 in self.mmus:
                oprot.writeString(iter93.encode('utf-8') if sys.version_info[0] == 2 else iter93)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 2)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadMMUs_args)
LoadMMUs_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'mmus', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.STRING, 'sessionID', 'UTF8', None, ),  # 2
)


class LoadMMUs_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype95, _vtype96, _size94) = iprot.readMapBegin()
                    for _i98 in range(_size94):
                        _key99 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val100 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key99] = _val100
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LoadMMUs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter101, viter102 in self.success.items():
                oprot.writeString(kiter101.encode('utf-8') if sys.version_info[0] == 2 else kiter101)
                oprot.writeString(viter102.encode('utf-8') if sys.version_info[0] == 2 else viter102)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(LoadMMUs_result)
LoadMMUs_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class CreateCheckpoint_args(object):
    """
    Attributes:
     - mmuID
     - sessionID

    """


    def __init__(self, mmuID=None, sessionID=None,):
        self.mmuID = mmuID
        self.sessionID = sessionID

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateCheckpoint_args')
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 1)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 2)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateCheckpoint_args)
CreateCheckpoint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'mmuID', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sessionID', 'UTF8', None, ),  # 2
)


class CreateCheckpoint_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateCheckpoint_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(CreateCheckpoint_result)
CreateCheckpoint_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class RestoreCheckpoint_args(object):
    """
    Attributes:
     - mmuID
     - sessionID
     - checkpointData

    """


    def __init__(self, mmuID=None, sessionID=None, checkpointData=None,):
        self.mmuID = mmuID
        self.sessionID = sessionID
        self.checkpointData = checkpointData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.mmuID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.sessionID = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.checkpointData = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestoreCheckpoint_args')
        if self.mmuID is not None:
            oprot.writeFieldBegin('mmuID', TType.STRING, 1)
            oprot.writeString(self.mmuID.encode('utf-8') if sys.version_info[0] == 2 else self.mmuID)
            oprot.writeFieldEnd()
        if self.sessionID is not None:
            oprot.writeFieldBegin('sessionID', TType.STRING, 2)
            oprot.writeString(self.sessionID.encode('utf-8') if sys.version_info[0] == 2 else self.sessionID)
            oprot.writeFieldEnd()
        if self.checkpointData is not None:
            oprot.writeFieldBegin('checkpointData', TType.STRING, 3)
            oprot.writeBinary(self.checkpointData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestoreCheckpoint_args)
RestoreCheckpoint_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'mmuID', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'sessionID', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'checkpointData', 'BINARY', None, ),  # 3
)


class RestoreCheckpoint_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MMIStandard.core.ttypes.MBoolResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestoreCheckpoint_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RestoreCheckpoint_result)
RestoreCheckpoint_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MMIStandard.core.ttypes.MBoolResponse, None], None, ),  # 0
)
fix_spec(all_structs)
del all_structs

